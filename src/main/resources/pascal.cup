package grammar;

import java.io.*;
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.XMLElement.*;
import javax.xml.stream.*;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at "+cur_token);
    }
    public static void newScope(){
	typenames.push(new HashSet<String>());
    }
    public static void deleteScope(){
	typenames.pop();
    }
    public static boolean lookupType(String name){
	for (HashSet<String> scope: typenames)
	    if (scope.contains(name)) return true;
	return false;
    }
    public static void addType(String name){
	typenames.peek().add(name);
    }
    public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
	super(lex,sf);
    }
:};

terminal AND, ARRAY, BEGIN, CASE, CONST, DIV, DO, DOWNTO, ELSE, END, FILE, FOR, FUNCTION, GOTO, IF, IN;
terminal LABEL, MOD, NIL, NOT, OF, OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, THEN, TO, TYPE, USES;
terminal UNTIL, VAR, WHILE, WITH, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, EQ, NE, LT, GT, LE, GE, DOT, LEFT;
terminal RIGHT, COMMA, SEMICOLON, COLON, DOTDOT, LEFTSQ, RIGHTSQ, PTR;
terminal READLN, READ, WRITE, WRITELN;
terminal String IDENT;
terminal Boolean BOOLCONST;
terminal Integer INTCONST;
terminal Double REALCONST;
terminal Character CHARCONST;
terminal String STRINGCONST;

non terminal File, Program, Module, ProgramHeading, Block, LabelDeclarationPart, LabelList, LabelDeclaration, ConstantDeclarationPart, Extern;
non terminal ConstDeclarationList, ConstDeclr, ConstantList, Constant, TypeDefinitionPart, TypeDecl, TypeDeclrList;
non terminal TypeDeclr, Type, SimpleType, ScalarType, SubrangeType, StructuredType, UnpackedType, ArrayType, SimpleTypeList;
non terminal RecordType, FieldList, FieldDeclList, FieldDecl, VariantFields, VariantList, Variant, SetType, FileType;
non terminal PointerType, VariableDeclarationPart, VarDecl, VarDeclrList, VarDeclr, IdentList, ProcedureAndFunctionDeclarationPart, ProcDeclr, FuncDeclr;
non terminal ProcHeader, FuncHeader, FormalParamDeclList, FormalParamDecl, Stmt, UnlabelledStmt, SimpleStmt, StructuredStmt;
non terminal Variable, WriteExprList, ExprList, WriteExpr, Expr, SimpleExpr, Term, Factor, Invocation, Set, ElementList;
non terminal Element, StatementPart, StmtList, ConditionalStmt, CaseStmtList, CaseStmt, LoopStmt, WithStmt, VariableList;

precedence nonassoc ELSE;



File ::=
        Program:p
    |   Module:m
    ;

Module ::=
        ConstantDeclarationPart:c
        TypeDefinitionPart:t
        VariableDeclarationPart:v
        ProcedureAndFunctionDeclarationPart:p
    ;

Program ::=
		ProgramHeading:p Block:b DOT
	;

ProgramHeading::=
        PROGRAM IDENT SEMICOLON
	|   PROGRAM IDENT LEFT IdentList:i RIGHT SEMICOLON
	;

Block::=
		Extern:e
		LabelDeclarationPart:l
		ConstantDeclarationPart:c
		TypeDefinitionPart:t
		VariableDeclarationPart:v
		ProcedureAndFunctionDeclarationPart:p
		StatementPart:s
	;

/* Blok "uses" */
Extern::=
		
	|	USES IdentList:i SEMICOLON
	;

LabelDeclarationPart::=
		/* Empty */
	|	LABEL LabelList:l SEMICOLON
	;

LabelList::=
		LabelDeclaration:ld
	|	LabelList:ll COMMA LabelDeclaration:l
	;

LabelDeclaration::=
		INTCONST
	;
	
ConstantDeclarationPart::=
		/* Empty */
	|	CONST ConstDeclarationList:c
	;
	
ConstDeclarationList::=
		ConstDeclr:c
	|	ConstDeclarationList:cdl ConstDeclr:cd
	;

ConstDeclr::=
		IDENT EQ Constant:c SEMICOLON
	;

ConstantList::=
		Constant:c
	|	ConstantList:cl COMMA Constant:c
	;

Constant::=
		INTCONST
	|	PLUS INTCONST
	|	MINUS INTCONST
	|	REALCONST
	|	PLUS REALCONST
	|	MINUS REALCONST
	|	IDENT
	|	PLUS IDENT
	|	MINUS IDENT
	|	STRINGCONST
	;

TypeDefinitionPart::=
		/* Empty */
	|	TypeDecl:t
	;

TypeDecl::=
		TYPE TypeDeclrList:t SEMICOLON
	;

TypeDeclrList::=
		TypeDeclr:t
	|	TypeDeclrList:tl SEMICOLON TypeDeclr:td
	;

TypeDeclr::=
		IDENT EQ Type:t
	|	IDENT EQ Type:t LEFTSQ IDENT RIGHTSQ
	|	IDENT EQ Type:t LEFTSQ SubrangeType:s RIGHTSQ
	;

Type::=
		SimpleType:s
	|	StructuredType:st
	|	PointerType:p
	;
	
SimpleType::=
		IDENT
	|	ScalarType:s
	|	SubrangeType:s
	;

ScalarType::=
		LEFT IdentList:il RIGHT
	;

SubrangeType::=
		Constant:c DOTDOT Constant:c2
	;

StructuredType::=
		UnpackedType:u
	|	PACKED UnpackedType:u2
	;

UnpackedType::=
		ArrayType:a
	|	RecordType:r
	|	SetType:s
	|	FileType:f
	;

ArrayType::=
		ARRAY LEFTSQ SimpleTypeList:s RIGHTSQ OF Type:t
	;

SimpleTypeList::=
		SimpleType:s
	|	SimpleTypeList:sl COMMA SimpleType:s2
	;

RecordType::=
		RECORD FieldList:f END
	;

FieldList::=
		FieldDeclList:f
	|	FieldDeclList:f2 SEMICOLON VariantFields:v
	;
	
FieldDeclList::=
		/* Empty */
	|	FieldDeclList:f SEMICOLON FieldDecl:fd
	;

FieldDecl::=
		/* Empty */
	|	IdentList:i COLON Type:t
	;

VariantFields::=
		CASE IDENT COLON IDENT OF VariantList:v
	|   CASE IDENT OF VariantList:v2
	;

VariantList::=
		Variant:v
	|   VariantList:vl SEMICOLON Variant:v2
	;

Variant::=
		/* Empty */
	|	ConstantList:c COLON LEFT FieldList:f RIGHT
	;

SetType::=
		SET OF SimpleType:s
	;
	
FileType::=
		FILE OF Type:t
	;
	
PointerType::=
		PTR IDENT
	;

VariableDeclarationPart::=
		/* Empty */
	|	VarDecl:v
	;

VarDecl::=
		VAR VarDeclrList:v
	;

VarDeclrList::=
		/* Empty */
	|	VarDeclrList:vl VarDeclr:vd
	;

VarDeclr::=
		IdentList COLON Type:t SEMICOLON
	;

IdentList::=
		/* Empty */
		IDENT
	|	IdentList:il COMMA IDENT:i
	;

ProcedureAndFunctionDeclarationPart::=
		/* Empty */
	|	ProcedureAndFunctionDeclarationPart:pp ProcDeclr:p SEMICOLON
	|	ProcedureAndFunctionDeclarationPart:pp2 FuncDeclr:f SEMICOLON
	;

ProcDeclr::=
		ProcHeader:p Block:b
	;

FuncDeclr::=
		FuncHeader:f Block:b
	;

ProcHeader::=
		PROCEDURE IDENT SEMICOLON
	|	PROCEDURE IDENT LEFT FormalParamDeclList:f RIGHT SEMICOLON
	;

FuncHeader::=
		FUNCTION IDENT COLON IDENT SEMICOLON
	|	FUNCTION IDENT LEFT FormalParamDeclList:f RIGHT COLON IDENT SEMICOLON
	;

FormalParamDeclList::=
		FormalParamDecl:f
	|	FormalParamDeclList:fl SEMICOLON FormalParamDecl:f2
	;

FormalParamDecl::=
		VAR IdentList:it COLON Type:t
	|	IdentList:il COLON Type:t2
	|	FUNCTION IdentList:il2 COLON Type:t3
	|	PROCEDURE IdentList:il3
	;

Stmt::=
		UnlabelledStmt:u
	|	INTCONST COLON UnlabelledStmt:u2
	;

UnlabelledStmt::=
		SimpleStmt:s
	|	StructuredStmt:ss
	;

SimpleStmt::=
		Variable:v ASSIGN Expr:e
	|	Invocation:i
	|	WRITE LEFT WriteExprList:w RIGHT
	|	WRITELN LEFT WriteExprList:w2 RIGHT
	|	READLN LEFT Variable:v2 RIGHT
	|	READ LEFT Variable:v3 RIGHT
	|	READLN
	|	READ
	|	WRITELN
	|	WRITE
	|	IDENT
	|	GOTO INTCONST
	|	/* Empty */
	;

StructuredStmt::=
		StatementPart:s
	|	ConditionalStmt:c
	|	LoopStmt:l
	|	WithStmt:w
	;

Variable::=
		IDENT
	|	Variable:v LEFTSQ ExprList:e RIGHTSQ
	|	Variable:v2 DOT IDENT
	|	Variable:v3 PTR
	;

WriteExprList::=
		WriteExpr:w
	|	WriteExprList:wl COMMA WriteExpr:we
	;

WriteExpr::=
		Expr:e
	|	Expr:e2 COLON Expr:e4
	|	Expr:e3 COLON Expr:e5 COLON Expr:e6
	;
	
ExprList::=
		Expr:e
	|	ExprList:el COMMA Expr:e2
	;
	
Expr::=
		SimpleExpr:se
	|	SimpleExpr:se2 EQ SimpleExpr:se9
	|	SimpleExpr:se3 NE SimpleExpr:se10
	|	SimpleExpr:se4 LT SimpleExpr:se11
	|	SimpleExpr:se5 LE SimpleExpr:se12
	|	SimpleExpr:se6 GT SimpleExpr:se13
	|	SimpleExpr:se7 GE SimpleExpr:se14
	|	SimpleExpr:se8 IN SimpleExpr:se15
	;

SimpleExpr::=
		Term:t
	|	PLUS Term:t2
	|	MINUS Term:t3
	|	SimpleExpr:se PLUS Term:t4
	|	SimpleExpr:se1 MINUS Term:t5
	|	SimpleExpr:se2 OR Term:t6
	;

Term::=
		Factor:f
	|	Term:t1 TIMES Factor:f1
	|	Term:t2 DIVIDE Factor:f2
	|	Term:t3 DIV Factor:f3
	|	Term:t4 MOD Factor:f4
	|	Term:t5 AND Factor:f5
	;

Factor::=
		Variable:v
	|	BOOLCONST
	|	INTCONST
	|	REALCONST
	|	CHARCONST
	|	STRINGCONST
	|	NIL
	|	LEFT Expr:e RIGHT
	|	Invocation:i
	|	Set:s
	|	NOT Factor:f
	;

Invocation::=
		IDENT LEFT ExprList:e RIGHT
	;

Set::=
		LEFTSQ ElementList:e RIGHTSQ
	|	LEFTSQ RIGHTSQ
	;

ElementList::=
		Element:e
	|	ElementList:el COMMA Element:e1
	;

Element::=
		Expr:e1
	|	Expr:e2 DOTDOT Expr:e3
	;

StatementPart::=
		BEGIN StmtList:s END
	;

StmtList::=
		Stmt:s
	|	StmtList:sl SEMICOLON Stmt:s2
	;

ConditionalStmt::=
		IF Expr:e THEN Stmt:s
	|	IF Expr:e2 THEN Stmt:s2 ELSE Stmt:s3
	|	CASE Expr OF CaseStmtList:c END
	;

CaseStmtList::=
		CaseStmt:c
	|	CaseStmtList:cl SEMICOLON CaseStmt:cs
	;

CaseStmt::=
		/* empty */
	|	ConstantList:cl COLON Stmt:s
	;

LoopStmt::=
		WHILE Expr:e DO Stmt:s
	|	REPEAT StmtList:sl UNTIL Expr:e2
	|	FOR IDENT ASSIGN Expr:e3 TO Expr:e5 DO Stmt:s3
	|	FOR IDENT ASSIGN Expr:e4 DOWNTO Expr:e6 DO Stmt:s6
	;


WithStmt::=
		WITH VariableList:v DO Stmt:s
	;

VariableList::=
		Variable:v
	|	VariableList:vl COMMA Variable:v2
	;
