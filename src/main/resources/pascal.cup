package grammar;

import java.io.*;
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.XMLElement.*;
import javax.xml.stream.*;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at "+cur_token);
    }
    public static void newScope(){
	typenames.push(new HashSet<String>());
    }
    public static void deleteScope(){
	typenames.pop();
    }
    public static boolean lookupType(String name){
	for (HashSet<String> scope: typenames)
	    if (scope.contains(name)) return true;
	return false;
    }
    public static void addType(String name){
	typenames.peek().add(name);
    }
    public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
	super(lex,sf);
    }
:};

terminal AND, ARRAY, BEGIN, CASE, CONST, DIV, DO, DOWNTO, ELSE, END, FILE, FOR, FUNCTION, GOTO, IF, IN;
terminal LABEL, MOD, NIL, NOT, OF, OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, THEN, TO, TYPE, USES;
terminal UNTIL, VAR, WHILE, WITH, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, EQ, NE, LT, GT, LE, GE, DOT, LEFT;
terminal RIGHT, COMMA, SEMICOLON, COLON, DOTDOT, LEFTSQ, RIGHTSQ, PTR;
terminal READLN, READ, WRITE, WRITELN;
terminal String IDENT;
terminal Boolean BOOLCONST;
terminal Integer INTCONST;
terminal Double REALCONST;
terminal Character CHARCONST;
terminal String STRINGCONST;

non terminal File, Program, Module, ProgramHeading, Block, LabelDeclarationPart, LabelList, LabelDeclaration, ConstantDeclarationPart, Extern;
non terminal ConstDeclarationList, ConstDeclr, ConstantList, Constant, TypeDefinitionPart, TypeDecl, TypeDeclrList;
non terminal TypeDeclr, Type, SimpleType, ScalarType, SubrangeType, StructuredType, UnpackedType, ArrayType, SimpleTypeList;
non terminal RecordType, FieldList, FieldDeclList, FieldDecl, VariantFields, VariantList, Variant, SetType, FileType;
non terminal PointerType, VariableDeclarationPart, VarDecl, VarDeclrList, VarDeclr, IdentList, ProcedureAndFunctionDeclarationPart, ProcDeclr, FuncDeclr;
non terminal ProcHeader, FuncHeader, FormalParamDeclList, FormalParamDecl, Stmt, UnlabelledStmt, SimpleStmt, StructuredStmt;
non terminal Variable, WriteExprList, ExprList, WriteExpr, Expr, SimpleExpr, Term, Factor, Invocation, Set, ElementList;
non terminal Element, StatementPart, StmtList, ConditionalStmt, CaseStmtList, CaseStmt, LoopStmt, WithStmt, VariableList;

precedence nonassoc ELSE;



File ::=
        Program:prog
    |   Module:mod
    ;

Module ::=
        ConstantDeclarationPart:cdp
        TypeDefinitionPart:tdp
        VariableDeclarationPart:vdp
        ProcedureAndFunctionDeclarationPart:pfdp
    ;

Program ::=
		ProgramHeading:ph Block:b DOT
	;

ProgramHeading::=
        PROGRAM IDENT SEMICOLON
	|   PROGRAM IDENT LEFT IdentList:il RIGHT SEMICOLON
	;

Block::=
		Extern:e
		LabelDeclarationPart:ldp
		ConstantDeclarationPart:cdp
		TypeDefinitionPart:tdp
		VariableDeclarationPart:vdp
		ProcedureAndFunctionDeclarationPart:pfdp
		StatementPart:sp
	;

/* Blok "uses" */
Extern::=
		
	|	USES IdentList:il SEMICOLON
	;

LabelDeclarationPart::=
		/* Empty */
	|	LABEL LabelList:ll SEMICOLON
	;

LabelList::=
		LabelDeclaration:ld
	|	LabelList:ll COMMA LabelDeclaration:ld1
	;

LabelDeclaration::=
		INTCONST
	;
	
ConstantDeclarationPart::=
		/* Empty */
	|	CONST ConstDeclarationList:cdl
	;
	
ConstDeclarationList::=
		ConstDeclr:cd
	|	ConstDeclarationList:cdl ConstDeclr:cd1
	;

ConstDeclr::=
		IDENT EQ Constant:c SEMICOLON
	;

ConstantList::=
		Constant:c
	|	ConstantList:cl COMMA Constant:c1
	;

Constant::=
		INTCONST
	|	PLUS INTCONST
	|	MINUS INTCONST
	|	REALCONST
	|	PLUS REALCONST
	|	MINUS REALCONST
	|	IDENT
	|	PLUS IDENT
	|	MINUS IDENT
	|	STRINGCONST
	;

TypeDefinitionPart::=
		/* Empty */
	|	TypeDecl:td
	;

TypeDecl::=
		TYPE TypeDeclrList:tdl SEMICOLON
	;

TypeDeclrList::=
		TypeDeclr:td
	|	TypeDeclrList:tdl SEMICOLON TypeDeclr:td1
	;

TypeDeclr::=
		IDENT EQ Type:t1
	|	IDENT EQ Type:t2 LEFTSQ IDENT RIGHTSQ
	|	IDENT EQ Type:t3 LEFTSQ SubrangeType:st RIGHTSQ
	;

Type::=
		SimpleType:st
	|	StructuredType:strt
	|	PointerType:pt
	;
	
SimpleType::=
		IDENT
	|	ScalarType:st
	|	SubrangeType:subt
	;

ScalarType::=
		LEFT IdentList:il RIGHT
	;

SubrangeType::=
		Constant:c DOTDOT Constant:c2
	;

StructuredType::=
		UnpackedType:ut
	|	PACKED UnpackedType:ut2
	;

UnpackedType::=
		ArrayType:at
	|	RecordType:rt
	|	SetType:st
	|	FileType:ft
	;

ArrayType::=
		ARRAY LEFTSQ SimpleTypeList:stl RIGHTSQ OF Type:t
	;

SimpleTypeList::=
		SimpleType:st
	|	SimpleTypeList:stl COMMA SimpleType:st2
	;

RecordType::=
		RECORD FieldList:fl END
	;

FieldList::=
		FieldDeclList:fdl1
	|	FieldDeclList:fdl2 SEMICOLON VariantFields:vf
	;
	
FieldDeclList::=
		/* Empty */
	|	FieldDeclList:fdl SEMICOLON FieldDecl:fd
	;

FieldDecl::=
		/* Empty */
	|	IdentList:il COLON Type:t
	;

VariantFields::=
		CASE IDENT COLON IDENT OF VariantList:vl
	|   CASE IDENT OF VariantList:vl2
	;

VariantList::=
		Variant:v
	|   VariantList:vl SEMICOLON Variant:v2
	;

Variant::=
		/* Empty */
	|	ConstantList:cl COLON LEFT FieldList:fl RIGHT
	;

SetType::=
		SET OF SimpleType:st
	;
	
FileType::=
		FILE OF Type:t
	;
	
PointerType::=
		PTR IDENT
	;

VariableDeclarationPart::=
		/* Empty */
	|	VarDecl:vd
	;

VarDecl::=
		VAR VarDeclrList:vdl
	;

VarDeclrList::=
		/* Empty */
	|	VarDeclrList:vdl VarDeclr:vd
	;

VarDeclr::=
		IdentList COLON Type:t SEMICOLON
	;

IdentList::=
		/* Empty */
		IDENT
	|	IdentList:il COMMA IDENT:i
	;

ProcedureAndFunctionDeclarationPart::=
		/* Empty */
	|	ProcedureAndFunctionDeclarationPart:pfdp1 ProcDeclr:pd SEMICOLON
	|	ProcedureAndFunctionDeclarationPart:pfdp2 FuncDeclr:fd SEMICOLON
	;

ProcDeclr::=
		ProcHeader:ph Block:b
	;

FuncDeclr::=
		FuncHeader:fh Block:b
	;

ProcHeader::=
		PROCEDURE IDENT SEMICOLON
	|	PROCEDURE IDENT LEFT FormalParamDeclList:fpdl RIGHT SEMICOLON
	;

FuncHeader::=
		FUNCTION IDENT COLON IDENT SEMICOLON
	|	FUNCTION IDENT LEFT FormalParamDeclList:fpdl RIGHT COLON IDENT SEMICOLON
	;

FormalParamDeclList::=
		FormalParamDecl:fpd
	|	FormalParamDeclList:fpdl SEMICOLON FormalParamDecl:fpd2
	;

FormalParamDecl::=
		VAR IdentList:it COLON Type:t
	|	IdentList:il1 COLON Type:t2
	|	FUNCTION IdentList:il2 COLON Type:t3
	|	PROCEDURE IdentList:il3
	;

Stmt::=
		UnlabelledStmt:us
	|	INTCONST COLON UnlabelledStmt:us2
	;

UnlabelledStmt::=
		SimpleStmt:ss
	|	StructuredStmt:strs
	;

SimpleStmt::=
		Variable:v ASSIGN Expr:e
	|	Invocation:i
	|	WRITE LEFT WriteExprList:w1 RIGHT
	|	WRITELN LEFT WriteExprList:w2 RIGHT
	|	READLN LEFT Variable:v2 RIGHT
	|	READ LEFT Variable:v3 RIGHT
	|	READLN
	|	READ
	|	WRITELN
	|	WRITE
	|	IDENT
	|	GOTO INTCONST
	|	/* Empty */
	;

StructuredStmt::=
		StatementPart:sp
	|	ConditionalStmt:cs
	|	LoopStmt:ls
	|	WithStmt:ws
	;

Variable::=
		IDENT
	|	Variable:v LEFTSQ ExprList:el RIGHTSQ
	|	Variable:v2 DOT IDENT
	|	Variable:v3 PTR
	;

WriteExprList::=
		WriteExpr:we
	|	WriteExprList:wel COMMA WriteExpr:we2
	;

WriteExpr::=
		Expr:e
	|	Expr:e2 COLON Expr:e3
	|	Expr:e4 COLON Expr:e5 COLON Expr:e6
	;
	
ExprList::=
		Expr:e
	|	ExprList:el COMMA Expr:e2
	;
	
Expr::=
		SimpleExpr:se
	|	SimpleExpr:se2 EQ SimpleExpr:se9
	|	SimpleExpr:se3 NE SimpleExpr:se10
	|	SimpleExpr:se4 LT SimpleExpr:se11
	|	SimpleExpr:se5 LE SimpleExpr:se12
	|	SimpleExpr:se6 GT SimpleExpr:se13
	|	SimpleExpr:se7 GE SimpleExpr:se14
	|	SimpleExpr:se8 IN SimpleExpr:se15
	;

SimpleExpr::=
		Term:t
	|	PLUS Term:t2
	|	MINUS Term:t3
	|	SimpleExpr:se PLUS Term:t4
	|	SimpleExpr:se1 MINUS Term:t5
	|	SimpleExpr:se2 OR Term:t6
	;

Term::=
		Factor:f
	|	Term:t1 TIMES Factor:f1
	|	Term:t2 DIVIDE Factor:f2
	|	Term:t3 DIV Factor:f3
	|	Term:t4 MOD Factor:f4
	|	Term:t5 AND Factor:f5
	;

Factor::=
		Variable:v
	|	BOOLCONST
	|	INTCONST
	|	REALCONST
	|	CHARCONST
	|	STRINGCONST
	|	NIL
	|	LEFT Expr:e RIGHT
	|	Invocation:i
	|	Set:s
	|	NOT Factor:f
	;

Invocation::=
		IDENT LEFT ExprList:el RIGHT
	;

Set::=
		LEFTSQ ElementList:el RIGHTSQ
	|	LEFTSQ RIGHTSQ
	;

ElementList::=
		Element:e
	|	ElementList:el COMMA Element:e1
	;

Element::=
		Expr:e1
	|	Expr:e2 DOTDOT Expr:e3
	;

StatementPart::=
		BEGIN StmtList:sl END
	;

StmtList::=
		Stmt:s
	|	StmtList:sl SEMICOLON Stmt:s2
	;

ConditionalStmt::=
		IF Expr:e THEN Stmt:s
	|	IF Expr:e2 THEN Stmt:s2 ELSE Stmt:s3
	|	CASE Expr:e3 OF CaseStmtList:csl END
	;

CaseStmtList::=
		CaseStmt:cs
	|	CaseStmtList:csl SEMICOLON CaseStmt:cs2
	;

CaseStmt::=
		/* empty */
	|	ConstantList:cl COLON Stmt:s
	;

LoopStmt::=
		WHILE Expr:e DO Stmt:s
	|	REPEAT StmtList:sl UNTIL Expr:e2
	|	FOR IDENT ASSIGN Expr:e3 TO Expr:e5 DO Stmt:s2
	|	FOR IDENT ASSIGN Expr:e4 DOWNTO Expr:e6 DO Stmt:s3
	;


WithStmt::=
		WITH VariableList:vl DO Stmt:s
	;

VariableList::=
		Variable:v
	|	VariableList:vl COMMA Variable:v2
	;
