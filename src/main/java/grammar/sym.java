
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20150326 (SVN rev 63)
//----------------------------------------------------

package grammar;

/** CUP generated interface containing symbol constants. */
public interface sym {
  /* terminals */
  public static final int DIVIDE = 41;
  public static final int FUNCTION = 14;
  public static final int WITH = 36;
  public static final int CONST = 6;
  public static final int PACKED = 24;
  public static final int GE = 47;
  public static final int CASE = 5;
  public static final int REPEAT = 28;
  public static final int ARRAY = 3;
  public static final int MINUS = 39;
  public static final int FOR = 13;
  public static final int WRITE = 66;
  public static final int STRINGCONST = 63;
  public static final int SEMICOLON = 52;
  public static final int NOT = 21;
  public static final int AND = 2;
  public static final int LT = 44;
  public static final int RIGHTSQ = 56;
  public static final int RECORD = 27;
  public static final int INTCONST = 60;
  public static final int TYPE = 32;
  public static final int NIL = 20;
  public static final int IN = 17;
  public static final int OR = 23;
  public static final int COMMA = 51;
  public static final int DOTDOT = 54;
  public static final int DIV = 7;
  public static final int BEGIN = 4;
  public static final int UNTIL = 33;
  public static final int LEFTSQ = 55;
  public static final int PLUS = 38;
  public static final int WRITELN = 67;
  public static final int ASSIGN = 37;
  public static final int IF = 16;
  public static final int PTR = 57;
  public static final int DOT = 48;
  public static final int LE = 46;
  public static final int LEFT = 49;
  public static final int OF = 22;
  public static final int EOF = 0;
  public static final int error = 1;
  public static final int PROGRAM = 26;
  public static final int MOD = 19;
  public static final int IDENT = 58;
  public static final int READLN = 64;
  public static final int EQ = 42;
  public static final int TIMES = 40;
  public static final int COLON = 53;
  public static final int ELSE = 10;
  public static final int READ = 65;
  public static final int TO = 31;
  public static final int FILE = 12;
  public static final int GOTO = 15;
  public static final int CHARCONST = 62;
  public static final int WHILE = 35;
  public static final int REALCONST = 61;
  public static final int THEN = 30;
  public static final int BOOLCONST = 59;
  public static final int NE = 43;
  public static final int END = 11;
  public static final int DOWNTO = 9;
  public static final int RIGHT = 50;
  public static final int LABEL = 18;
  public static final int GT = 45;
  public static final int VAR = 34;
  public static final int PROCEDURE = 25;
  public static final int DO = 8;
  public static final int SET = 29;
  public static final String[] terminalNames = new String[] {
  "EOF",
  "error",
  "AND",
  "ARRAY",
  "BEGIN",
  "CASE",
  "CONST",
  "DIV",
  "DO",
  "DOWNTO",
  "ELSE",
  "END",
  "FILE",
  "FOR",
  "FUNCTION",
  "GOTO",
  "IF",
  "IN",
  "LABEL",
  "MOD",
  "NIL",
  "NOT",
  "OF",
  "OR",
  "PACKED",
  "PROCEDURE",
  "PROGRAM",
  "RECORD",
  "REPEAT",
  "SET",
  "THEN",
  "TO",
  "TYPE",
  "UNTIL",
  "VAR",
  "WHILE",
  "WITH",
  "ASSIGN",
  "PLUS",
  "MINUS",
  "TIMES",
  "DIVIDE",
  "EQ",
  "NE",
  "LT",
  "GT",
  "LE",
  "GE",
  "DOT",
  "LEFT",
  "RIGHT",
  "COMMA",
  "SEMICOLON",
  "COLON",
  "DOTDOT",
  "LEFTSQ",
  "RIGHTSQ",
  "PTR",
  "IDENT",
  "BOOLCONST",
  "INTCONST",
  "REALCONST",
  "CHARCONST",
  "STRINGCONST",
  "READLN",
  "READ",
  "WRITE",
  "WRITELN"
  };

  public static String terminal_name( int id ) {
    switch ( id ) {
      case 41: return "DIVIDE";
      case 14: return "FUNCTION";
      case 36: return "WITH";
      case 6: return "CONST";
      case 24: return "PACKED";
      case 47: return "GE";
      case 5: return "CASE";
      case 28: return "REPEAT";
      case 3: return "ARRAY";
      case 39: return "MINUS";
      case 13: return "FOR";
      case 66: return "WRITE";
      case 63: return "STRINGCONST";
      case 52: return "SEMICOLON";
      case 21: return "NOT";
      case 2: return "AND";
      case 44: return "LT";
      case 56: return "RIGHTSQ";
      case 27: return "RECORD";
      case 60: return "INTCONST";
      case 32: return "TYPE";
      case 20: return "NIL";
      case 17: return "IN";
      case 23: return "OR";
      case 51: return "COMMA";
      case 54: return "DOTDOT";
      case 7: return "DIV";
      case 4: return "BEGIN";
      case 33: return "UNTIL";
      case 55: return "LEFTSQ";
      case 38: return "PLUS";
      case 67: return "WRITELN";
      case 37: return "ASSIGN";
      case 16: return "IF";
      case 57: return "PTR";
      case 48: return "DOT";
      case 46: return "LE";
      case 49: return "LEFT";
      case 22: return "OF";
      case 0: return "EOF";
      case 1: return "error";
      case 26: return "PROGRAM";
      case 19: return "MOD";
      case 58: return "IDENT";
      case 65: return "READLN";
      case 42: return "EQ";
      case 40: return "TIMES";
      case 53: return "COLON";
      case 10: return "ELSE";
      case 64: return "READ";
      case 31: return "TO";
      case 12: return "FILE";
      case 15: return "GOTO";
      case 62: return "CHARCONST";
      case 35: return "WHILE";
      case 61: return "REALCONST";
      case 30: return "THEN";
      case 59: return "BOOLCONST";
      case 43: return "NE";
      case 11: return "END";
      case 9: return "DOWNTO";
      case 50: return "RIGHT";
      case 18: return "LABEL";
      case 45: return "GT";
      case 34: return "VAR";
      case 25: return "PROCEDURE";
      case 8: return "DO";
      case 29: return "SET";
      default: return "unknown terminal" + id;
    }
  }

  public static String non_terminal_name( int id ) {
    switch ( id ) {
      case 50: return "SimpleStmt";
      case 67: return "CaseStmtList";
      case 57: return "SimpleExpr";
      case 31: return "VariantList";
      case 68: return "CaseStmt";
      case 15: return "TypeDecl";
      case 69: return "LoopStmt";
      case 59: return "Factor";
      case 35: return "PointerType";
      case 49: return "UnlabelledStmt";
      case 23: return "UnpackedType";
      case 45: return "FuncHeader";
      case 54: return "ExprList";
      case 28: return "FieldDeclList";
      case 17: return "TypeDeclr";
      case 39: return "VarDeclr";
      case 27: return "FieldList";
      case 62: return "ElementList";
      case 6: return "LabelDeclrList";
      case 52: return "Variable";
      case 66: return "ConditionalStmt";
      case 48: return "Stmt";
      case 56: return "Expr";
      case 3: return "Block";
      case 10: return "ConstDeclrList";
      case 46: return "FormalParamDeclList";
      case 38: return "VarDeclrList";
      case 22: return "StructuredType";
      case 37: return "VarDecl";
      case 24: return "ArrayType";
      case 14: return "TypeDeclOpt";
      case 2: return "ProgramHeading";
      case 61: return "Set";
      case 1: return "Program";
      case 12: return "ConstantList";
      case 0: return "$START";
      case 71: return "VariableList";
      case 34: return "FileType";
      case 19: return "SimpleType";
      case 16: return "TypeDeclrList";
      case 64: return "CompoundStmt";
      case 13: return "Constant";
      case 44: return "ProcHeader";
      case 55: return "WriteExpr";
      case 4: return "LabelDeclOpt";
      case 32: return "Variant";
      case 53: return "WriteExprList";
      case 70: return "WithStmt";
      case 41: return "ProcDeclrList";
      case 65: return "StmtList";
      case 40: return "IdentList";
      case 63: return "Element";
      case 20: return "ScalarType";
      case 36: return "VarDeclOpt";
      case 18: return "Type";
      case 21: return "SubrangeType";
      case 26: return "RecordType";
      case 47: return "FormalParamDecl";
      case 29: return "FieldDecl";
      case 60: return "Invocation";
      case 7: return "LabelDeclr";
      case 5: return "LabelDecl";
      case 33: return "SetType";
      case 51: return "StructuredStmt";
      case 43: return "FuncDeclr";
      case 42: return "ProcDeclr";
      case 8: return "ConstantDeclOpt";
      case 58: return "Term";
      case 9: return "ConstantDecl";
      case 25: return "SimpleTypeList";
      case 30: return "VariantFields";
      case 11: return "ConstDeclr";
      default: return "unknown non_terminal" + id;
    }
  }
  public static String rule_name( int id ) {
    switch ( id ) {
      case 170: return "VariableList ::= VariableList COMMA Variable ";
      case 169: return "VariableList ::= Variable ";
      case 168: return "WithStmt ::= WITH VariableList DO Stmt ";
      case 167: return "LoopStmt ::= FOR IDENT ASSIGN Expr DOWNTO Expr DO Stmt ";
      case 166: return "LoopStmt ::= FOR IDENT ASSIGN Expr TO Expr DO Stmt ";
      case 165: return "LoopStmt ::= REPEAT StmtList UNTIL Expr ";
      case 164: return "LoopStmt ::= WHILE Expr DO Stmt ";
      case 163: return "CaseStmt ::= ConstantList COLON Stmt ";
      case 162: return "CaseStmt ::= ";
      case 161: return "CaseStmtList ::= CaseStmtList SEMICOLON CaseStmt ";
      case 160: return "CaseStmtList ::= CaseStmt ";
      case 159: return "ConditionalStmt ::= CASE Expr OF CaseStmtList END ";
      case 158: return "ConditionalStmt ::= IF Expr THEN Stmt ELSE Stmt ";
      case 157: return "ConditionalStmt ::= IF Expr THEN Stmt ";
      case 156: return "StmtList ::= StmtList SEMICOLON Stmt ";
      case 155: return "StmtList ::= Stmt ";
      case 154: return "CompoundStmt ::= BEGIN StmtList END ";
      case 153: return "Element ::= Expr DOTDOT Expr ";
      case 152: return "Element ::= Expr ";
      case 151: return "ElementList ::= ElementList COMMA Element ";
      case 150: return "ElementList ::= Element ";
      case 149: return "Set ::= LEFTSQ RIGHTSQ ";
      case 148: return "Set ::= LEFTSQ ElementList RIGHTSQ ";
      case 147: return "Invocation ::= IDENT LEFT ExprList RIGHT ";
      case 146: return "Factor ::= NOT Factor ";
      case 145: return "Factor ::= Set ";
      case 144: return "Factor ::= Invocation ";
      case 143: return "Factor ::= LEFT Expr RIGHT ";
      case 142: return "Factor ::= NIL ";
      case 141: return "Factor ::= STRINGCONST ";
      case 140: return "Factor ::= CHARCONST ";
      case 139: return "Factor ::= REALCONST ";
      case 138: return "Factor ::= INTCONST ";
      case 137: return "Factor ::= BOOLCONST ";
      case 136: return "Factor ::= Variable ";
      case 135: return "Term ::= Term AND Factor ";
      case 134: return "Term ::= Term MOD Factor ";
      case 133: return "Term ::= Term DIV Factor ";
      case 132: return "Term ::= Term DIVIDE Factor ";
      case 131: return "Term ::= Term TIMES Factor ";
      case 130: return "Term ::= Factor ";
      case 129: return "SimpleExpr ::= SimpleExpr OR Term ";
      case 128: return "SimpleExpr ::= SimpleExpr MINUS Term ";
      case 127: return "SimpleExpr ::= SimpleExpr PLUS Term ";
      case 126: return "SimpleExpr ::= MINUS Term ";
      case 125: return "SimpleExpr ::= PLUS Term ";
      case 124: return "SimpleExpr ::= Term ";
      case 123: return "Expr ::= SimpleExpr IN SimpleExpr ";
      case 122: return "Expr ::= SimpleExpr GE SimpleExpr ";
      case 121: return "Expr ::= SimpleExpr GT SimpleExpr ";
      case 120: return "Expr ::= SimpleExpr LE SimpleExpr ";
      case 119: return "Expr ::= SimpleExpr LT SimpleExpr ";
      case 118: return "Expr ::= SimpleExpr NE SimpleExpr ";
      case 117: return "Expr ::= SimpleExpr EQ SimpleExpr ";
      case 116: return "Expr ::= SimpleExpr ";
      case 115: return "ExprList ::= ExprList COMMA Expr ";
      case 114: return "ExprList ::= Expr ";
      case 113: return "WriteExpr ::= Expr COLON Expr COLON Expr ";
      case 112: return "WriteExpr ::= Expr COLON Expr ";
      case 111: return "WriteExpr ::= Expr ";
      case 110: return "WriteExprList ::= WriteExprList COMMA WriteExpr ";
      case 109: return "WriteExprList ::= WriteExpr ";
      case 108: return "Variable ::= Variable PTR ";
      case 107: return "Variable ::= Variable DOT IDENT ";
      case 106: return "Variable ::= Variable LEFTSQ ExprList RIGHTSQ ";
      case 105: return "Variable ::= IDENT ";
      case 104: return "StructuredStmt ::= WithStmt ";
      case 103: return "StructuredStmt ::= LoopStmt ";
      case 102: return "StructuredStmt ::= ConditionalStmt ";
      case 101: return "StructuredStmt ::= CompoundStmt ";
      case 100: return "SimpleStmt ::= ";
      case 99: return "SimpleStmt ::= GOTO INTCONST ";
      case 98: return "SimpleStmt ::= IDENT ";
      case 97: return "SimpleStmt ::= WRITELN LEFT WriteExprList RIGHT ";
      case 96: return "SimpleStmt ::= WRITE LEFT WriteExprList RIGHT ";
      case 95: return "SimpleStmt ::= Invocation ";
      case 94: return "SimpleStmt ::= Variable ASSIGN Expr ";
      case 93: return "UnlabelledStmt ::= StructuredStmt ";
      case 92: return "UnlabelledStmt ::= SimpleStmt ";
      case 91: return "Stmt ::= INTCONST COLON UnlabelledStmt ";
      case 90: return "Stmt ::= UnlabelledStmt ";
      case 89: return "FormalParamDecl ::= PROCEDURE IdentList ";
      case 88: return "FormalParamDecl ::= FUNCTION IdentList COLON Type ";
      case 87: return "FormalParamDecl ::= IdentList COLON Type ";
      case 86: return "FormalParamDecl ::= VAR IdentList COLON Type ";
      case 85: return "FormalParamDeclList ::= FormalParamDeclList SEMICOLON FormalParamDecl ";
      case 84: return "FormalParamDeclList ::= FormalParamDecl ";
      case 83: return "FuncHeader ::= FUNCTION IDENT LEFT FormalParamDeclList RIGHT COLON IDENT SEMICOLON ";
      case 82: return "FuncHeader ::= FUNCTION IDENT COLON IDENT SEMICOLON ";
      case 81: return "ProcHeader ::= PROCEDURE IDENT LEFT FormalParamDeclList RIGHT SEMICOLON ";
      case 80: return "ProcHeader ::= PROCEDURE IDENT SEMICOLON ";
      case 79: return "FuncDeclr ::= FuncHeader Block ";
      case 78: return "ProcDeclr ::= ProcHeader Block ";
      case 77: return "ProcDeclrList ::= ProcDeclrList FuncDeclr SEMICOLON ";
      case 76: return "ProcDeclrList ::= ProcDeclrList ProcDeclr SEMICOLON ";
      case 75: return "ProcDeclrList ::= ";
      case 74: return "IdentList ::= IdentList COMMA IDENT ";
      case 73: return "IdentList ::= ";
      case 72: return "VarDeclr ::= IdentList COLON Type ";
      case 71: return "VarDeclrList ::= VarDeclrList SEMICOLON VarDeclr ";
      case 70: return "VarDeclrList ::= ";
      case 69: return "VarDecl ::= VAR VarDeclrList SEMICOLON ";
      case 68: return "VarDeclOpt ::= VarDecl ";
      case 67: return "VarDeclOpt ::= ";
      case 66: return "PointerType ::= PTR IDENT ";
      case 65: return "FileType ::= FILE OF Type ";
      case 64: return "SetType ::= SET OF SimpleType ";
      case 63: return "Variant ::= ConstantList COLON LEFT FieldList RIGHT ";
      case 62: return "Variant ::= ";
      case 61: return "VariantList ::= VariantList SEMICOLON Variant ";
      case 60: return "VariantList ::= Variant ";
      case 59: return "VariantFields ::= CASE IDENT OF VariantList ";
      case 58: return "VariantFields ::= CASE IDENT COLON IDENT OF VariantList ";
      case 57: return "FieldDecl ::= IdentList COLON Type ";
      case 56: return "FieldDecl ::= ";
      case 55: return "FieldDeclList ::= FieldDeclList SEMICOLON FieldDecl ";
      case 54: return "FieldDeclList ::= ";
      case 53: return "FieldList ::= FieldDeclList SEMICOLON VariantFields ";
      case 52: return "FieldList ::= FieldDeclList ";
      case 51: return "RecordType ::= RECORD FieldList END ";
      case 50: return "SimpleTypeList ::= SimpleTypeList COMMA SimpleType ";
      case 49: return "SimpleTypeList ::= SimpleType ";
      case 48: return "ArrayType ::= ARRAY LEFTSQ SimpleTypeList RIGHTSQ OF Type ";
      case 47: return "UnpackedType ::= FileType ";
      case 46: return "UnpackedType ::= SetType ";
      case 45: return "UnpackedType ::= RecordType ";
      case 44: return "UnpackedType ::= ArrayType ";
      case 43: return "StructuredType ::= PACKED UnpackedType ";
      case 42: return "StructuredType ::= UnpackedType ";
      case 41: return "SubrangeType ::= Constant DOTDOT Constant ";
      case 40: return "ScalarType ::= LEFT IdentList RIGHT ";
      case 39: return "SimpleType ::= SubrangeType ";
      case 38: return "SimpleType ::= ScalarType ";
      case 37: return "SimpleType ::= IDENT ";
      case 36: return "Type ::= PointerType ";
      case 35: return "Type ::= StructuredType ";
      case 34: return "Type ::= SimpleType ";
      case 33: return "TypeDeclr ::= IDENT EQ Type ";
      case 32: return "TypeDeclrList ::= TypeDeclrList SEMICOLON TypeDeclr ";
      case 31: return "TypeDeclrList ::= TypeDeclr ";
      case 30: return "TypeDecl ::= TYPE TypeDeclrList SEMICOLON ";
      case 29: return "TypeDeclOpt ::= TypeDecl ";
      case 28: return "TypeDeclOpt ::= ";
      case 27: return "Constant ::= STRINGCONST ";
      case 26: return "Constant ::= MINUS IDENT ";
      case 25: return "Constant ::= PLUS IDENT ";
      case 24: return "Constant ::= IDENT ";
      case 23: return "Constant ::= MINUS REALCONST ";
      case 22: return "Constant ::= PLUS REALCONST ";
      case 21: return "Constant ::= REALCONST ";
      case 20: return "Constant ::= MINUS INTCONST ";
      case 19: return "Constant ::= PLUS INTCONST ";
      case 18: return "Constant ::= INTCONST ";
      case 17: return "ConstantList ::= ConstantList COMMA Constant ";
      case 16: return "ConstantList ::= Constant ";
      case 15: return "ConstDeclr ::= IDENT EQ Constant ";
      case 14: return "ConstDeclrList ::= ConstDeclrList COMMA ConstDeclr ";
      case 13: return "ConstDeclrList ::= ConstDeclr ";
      case 12: return "ConstantDecl ::= CONST ConstDeclrList SEMICOLON ";
      case 11: return "ConstantDeclOpt ::= ConstantDecl ";
      case 10: return "ConstantDeclOpt ::= ";
      case 9: return "LabelDeclr ::= INTCONST ";
      case 8: return "LabelDeclrList ::= LabelDeclrList COMMA LabelDeclr ";
      case 7: return "LabelDeclrList ::= LabelDeclr ";
      case 6: return "LabelDecl ::= LABEL LabelDeclrList SEMICOLON ";
      case 5: return "LabelDeclOpt ::= LabelDecl ";
      case 4: return "LabelDeclOpt ::= ";
      case 3: return "Block ::= LabelDeclOpt ConstantDeclOpt TypeDeclOpt VarDeclOpt ProcDeclrList CompoundStmt ";
      case 2: return "ProgramHeading ::= PROGRAM IDENT LEFT IdentList RIGHT SEMICOLON ";
      case 1: return "Program ::= ProgramHeading Block DOT ";
      case 0: return "$START ::= Program EOF ";
      default: return "unknown rule" + id;
    }
  }
}

